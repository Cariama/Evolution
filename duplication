 def __init__(self,n_entities,x,y):
        self.x,self.y=x,y #plateau
        self.n_entities=n_entities
        self.food=Evol.food_init(self)#liste des coo des pommes
        start_loc=Evol.init_location(self)
        sence=2.58
        r_hitbox=0.5
        self.t_day=24 #temps d'une journée
        self.t=0 #temps actuel
        self.food_hitbox=0.125
        self.entities=[[start_loc[i],Evol.base_direction(self,start_loc[i])+Evol.move_direction(), Evol.rand_speed(1),r_hitbox,rd.randint(1,10),0,sence,str(i)]for i in range(n_entities)] 
#        (0(position),1(angle de la direction),(2)speed,(3)rayon hitbox,(4)énergie de base,(5)comportement,(6)sense,(-1)repr)
#        print(self.entities)
        
    def moveToward(self,entity,coo):
        direction= coo-entity[0]/Evol.dist(entity[0],coo)
        vitesse=min(Evol.dist(entity[0],coo)-entity[3]-self.food_hitbox,entity[2])
        entity[0]=entity[0]+direction*vitesse
        entity[4]=entity[4]-0.25*vitesse
    
    def dup(self,entity):
#        (0(position),1(angle de la direction),(2)speed,(3)rayon hitbox,(4)énergie de base,(5)comportement, sense (-1)repr)
        new_entity=(entity[0],Evol.base_direction(self,entity[0])+Evol.move_direction(),Evol.rand_speed(entity[2]),entity[4]/2,0,entity[6],'@')
        self.entities.append(new_entity)
        entity[4]=entity[4]/2
        #!!!penser à rajouter les trucs
        
    def goForFood(self,entity):
        vision=entity[6]
        done=False
        print("food?")
        for miam in self.food:
            d=self.x**2+self.y**2
            di=Evol.dist(miam,entity[0])+self.food_hitbox
            if di<=vision and di<d:
#                print("trouvé1")
                d=di
                the_miam=miam
                done=True
        if done==True:
            print("miam?")
            Evol.moveToward(self,entity,the_miam)
        return done
        
   #Déplacement de base
        for entity in self.entities:
            if False:#gohome==True:
                pass
            elif Evol.goForFood(self,entity):
                pass
            else:    
                entity[0]=entity[0]+entity[2]*Evol.speedDirection(entity[1])
                Evol.anti_exit(self,entity)
                entity[4]-=0.25*entity[2]
        #Si ils se touchent
